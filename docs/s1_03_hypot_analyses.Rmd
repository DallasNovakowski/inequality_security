---
title: "s1_03_hypot_analyses"
author: "Dallas Novakowski"
date: "20/01/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)


library(tidyverse)
library(kableExtra)

library(rstatix)
library(stats)  #aov function
library(ggpubr)  #ggqqplot

source(here::here("scripts","hypotheses.R"), local = knitr::knit_global())
source(here::here("scripts","measures.R"), local = knitr::knit_global())
```


```{r testdata, eval=TRUE}
set.seed(123) #Standardizes the numbers generated by rnorm; see Chapter 5
N <- 200 #Number of participants; graduate students
inequality <- sample(c(0,1), replace=TRUE, size=N)


# inequality <- rnorm(N, 175, 7) #IV; hours since dawn
likely_envy <- 3*inequality + rnorm(N, 0, 5) #Suspected mediator; coffee consumption 
security_spending <- 2*likely_envy + rnorm(N, 0, 5) #DV; wakefulness
inequality <- as.factor(inequality)

ineq_data <- data.frame(inequality, likely_envy, security_spending)
```


## Study 1a/1b/1c

```{r t-tests, echo=TRUE, eval=TRUE}

#ineq_data$likely_envy <- rowSums(ineq_data[,c("partner_envy", "partner_jealous", "partner_frustrated", "partner_bitter")

# ltm::cronbach.alpha(ineq_data$likely_envy,CI=TRUE)
# Acceptable if mean alpha >= .7
# Otherwise, try dropping each item until >= .7 is achieved
# If no >= .7 solution found, forego mediaiton analyses

# Outliers
ineq_data %>%
  group_by(inequality) %>%
  identify_outliers(security_spending)

#shapiro normality by group
ineq_data %>%
  group_by(inequality) %>%
  shapiro_test(security_spending)

ggqqplot(ineq_data, x = "security_spending", facet.by = "inequality")

ineq_data %>% levene_test(security_spending ~ as.factor(inequality))

#welch's
ineq_t_test <- ineq_data %>% 
  t_test(security_spending ~ inequality) %>%
  add_significance()
ineq_t_test

ineq_data %>%  cohens_d(security_spending ~ inequality, var.equal = TRUE)

# student's (equal variances)
# ineq_t_test <- ineq_data %>% 
#   t_test(security_spending ~ inequality, var.equal = TRUE) %>%
#   add_significance()
# ineq_t_test



# ineq_data %>%  cohens_d(security_spending ~ inequality, var.equal = TRUE)

bxp <- ggboxplot(
  ineq_data, x = "inequality", y = "security_spending", 
  ylab = "Security Spending", xlab = "Inequality", add = "jitter"
  )

ineq_t_test <- ineq_t_test %>% add_xy_position(x = "group")

bxp + 
  stat_pvalue_manual(ineq_t_test, tip.length = 0) +
  labs(subtitle = get_test_label(ineq_t_test, detailed = TRUE))
```

`r h1a`

`r h1a.1`

```{r mediat-predict, eval=FALSE, echo=TRUE}
#predicting mediator
m_envy_med1 <- lm(likely_envy ~ inequality, data = ineq_data)
```

`r h1a.2`

```{r vis-likely-security, eval=FALSE, echo=TRUE}
# test for relationship between p. attack likelihood and security spending
m_envy_med2 <- lm(security_spending ~ likely_envy + inequality, data = ineq_data)
```

`r h1a.3`

```{r vis-mod-med, eval=FALSE, echo = TRUE}
# see https://ademos.people.uic.edu/Chapter15.html#41_create_the_necessary_regression_models
library(mediation)
mediate <- mediation::mediate
# ACME: Average Causal Mediation Effect [total effect - direct effect]
# ADE: Average Direct Effect [total effect - indirect effect]
# Total Effect: Direct (ADE) + Indirect (ACME)
# Prop. Mediated: Conceptually ACME / Total effect 
#(This tells us how much of the total effect our indirect effect is ?explaining?)

m_envy_med_full <- mediate(m_envy_med1, m_envy_med2, boot = TRUE,   
                           boot.ci.type = "bca", sims = 2000,treat="inequality",
                           mediator="likely_envy")


plot(m_envy_med_full)
summary(m_envy_med_full)
```

## Study 1d


```{r}
#ineq_data$likely_envy <- rowSums(ineq_data[,c("partner_envy", "partner_jealous", "partner_frustrated", "partner_bitter")

# ltm::cronbach.alpha(ineq_data$likely_envy,CI=TRUE)
# Acceptable if mean alpha >= .7
# Otherwise, try dropping each item until >= .7 is achieved
# If no >= .7 solution found, forego mediaiton analyses

reasonable_income_text <- "My partner's assigned income is reasonable"
fair_distribution_text <- "The way incomes were given for this game is fair"
deserved_income_text <- "I deserve my income for this game"
deserved_role_text <- "I deserve my role for this game"
```



```{r merit-data, echo=TRUE, eval=TRUE}
ineq_merit_data <- ineq_data

ineq_merit_data$merit <- sample(c(0,1), replace=TRUE, size=N)

ineq_merit_data$merit <- ifelse(ineq_merit_data$merit == 1,"merit", "random")

ineq_merit_data$inequality <- ifelse(ineq_merit_data$inequality == 1,"unequal", "equal")


ineq_merit_data$inequality <- as.factor(ineq_merit_data$inequality)
ineq_merit_data$merit <- as.factor(ineq_merit_data$merit)


```


```{r merit-assumptions}
outliers_merit <- ineq_merit_data %>%
  group_by(merit, inequality) %>%
  identify_outliers(security_spending)

# Build the linear model
lm_merit  <- lm(security_spending ~ as.factor(inequality)*as.factor(merit),
             data = ineq_merit_data)

# Create a QQ plot of residuals
qq_merit <- ggqqplot(residuals(lm_merit))

#shapiro normality
shap_merit <- shapiro_test(residuals(lm_merit))

#normality by groups
shap_group_merit <- ineq_merit_data %>%
  group_by(merit, inequality) %>%
  shapiro_test(security_spending)

# qqplot by group
qq_group_merit <- ggqqplot(ineq_merit_data, "security_spending", ggtheme = theme_bw()) +
  facet_grid(inequality ~ merit)

levene_merit <- ineq_merit_data %>% levene_test(security_spending ~ as.factor(inequality)*as.factor(merit))


# https://easystats.github.io/effectsize/articles/effectsize.html
# see above for 95%ci for eta squared
```


```{r anova-lm}
# Method 1: stats::lm & car::Anova 
#fit model
lm_merit <- lm(security_spending ~ inequality*merit, data = ineq_merit_data)

#analyze model
car_lm_merit <- Anova(lm_merit)

#Summarize model
car_lm_sum <- anova_summary(car_lm_merit) 

```


```{r anova-aov}
# Method 2: stats::aov
# fit model 
aov_merit <- aov(security_spending ~ inequality*merit, 
               data = ineq_merit_data)
#analyze model
car_aov_merit <- Anova(aov_merit)

#Summarize model
car_aov_sum <- anova_summary(car_aov_merit)
```

```{r anova-anovatest}
# Method 3: rstatix::anova_test
anova_merit <- ineq_merit_data %>% anova_test(security_spending ~ inequality*merit
# ,type = 3
)
```
```{r pairwise}
#planned comparisons, using method 2
# tkmerit <- stats::TukeyHSD(aov_merit)
tukey_merit <- aov_merit  %>% tukey_hsd()


#provides main effects at different levels (simple main effects)
library(emmeans)
merit_mod <- ineq_merit_data %>%
  group_by(merit) %>%
  emmeans_test(security_spending ~ inequality, p.adjust.method = "bonferroni")

```


```{r merit-plot, echo=TRUE, eval=FALSE}
#doesn't do multiple factors
# get_comparisons(res.aov)

merit_mod <- merit_mod %>% add_xy_position(x = "merit")

bxp <- ggboxplot(
  ineq_merit_data, x = "merit", y = "security_spending",
  color = "inequality", palette = "jco"
  )

#ggsignif?

bxp +
  stat_pvalue_manual(merit_mod) +
  labs(
    subtitle = get_test_label(anova_merit, detailed = TRUE),     # only works using rstatix::anova_test method
    caption = get_pwc_label(merit_mod)
    )
```



```{r merit-mediat-predict, eval=FALSE, echo=TRUE}
#predicting mediator
m_merit_med1 <- lm(likely_attack ~ inequality*merit, data = ineq_merit_data)
```



```{r merit-likely-security, eval=FALSE, echo=TRUE}
# test for relationship between p. attack likelihood and security spending
m_merit_likely_security <- lm(security_spending ~ likely_attack, data = ineq_merit_data)
```


```{r merit-mediat-dv, eval=FALSE, echo=TRUE}
# model with mediator: likely_attack (or perceived likelihood of partner attacking)
m_merit_med2 <- lm(security_spending ~ inequality*merit + likely_attack, 
                 data = ineq_merit_data)
```

```{r merit-mod-med, eval=FALSE, echo = TRUE}
# see https://ademos.people.uic.edu/Chapter15.html#41_create_the_necessary_regression_models
library(mediation)
mediate <- mediation::mediate
# ACME: Average Causal Mediation Effect [total effect - direct effect]
# ADE: Average Direct Effect [total effect - indirect effect]
# Total Effect: Direct (ADE) + Indirect (ACME)
# Prop. Mediated: Conceptually ACME / Total effect 
#(This tells us how much of the total effect our indirect effect is ?explaining?)
# specify mediation at high visibility
m_merit_modmed_himerit <- mediate(m_merit_med1, m_merit_med2,    
                           covariates = list(merit = 1), boot = TRUE,   
                           boot.ci.type = "bca", sims = 2000, treat="inequality",
                           mediator="likely_attack")
plot(m_merit_modmed_himerit, xlim = 0:1)
summary(m_merit_modmed_himerit) 
# Specify mediation at low visibility
m_merit_modmed_lowmerit <- mediate(m_merit_med1, m_merit_med2,    
                           covariates = list(merit = 0), boot = TRUE,   
                           boot.ci.type = "bca", sims = 2000, treat="inequality",
                           mediator="likely_attack")
plot(m_merit_modmed_lowmerit, xlim = 0:1)
summary(m_merit_modmed_lowmerit) 
```

```{r merit-modmed-test, eval=FALSE, echo = TRUE}
modmed_testmerit <- mediate(m_merit_modmed_himerit, m_merit_modmed_lowmerit, 
                            boot = TRUE,  boot.ci.type = "bca", sims = 2000, 
                            treat="inequality", mediator="likely_attack")   
#We don't specify anything about the moderator in this code yet
merit_modmed_test <- test.modmed(modmed_testmerit, covariates.1 = list(merit = 0),   
            covariates.2 = list(merit = 1), sims = 2000)
#Here we specify both levels of the moderator that we want to test
merit_modmed_test
```

## Study 1f

### Study 1f Hypotheses

The third experiment will keep a constant presence of inequality, but manipulate whether the partner is a member of an ingroup or outgroup, and whether the incomes are distributed randomly, by an **ingroup third-party**.


```{r group-aov, echo=TRUE, eval=FALSE}
aov_group <- aov(security_spending ~ as.factor(agentic)*as.factor(outgroup), 
               data = ineq_group_data, type="III")
```


```{r group-tukey, echo=TRUE, eval=FALSE}
tukey_group <- stats::TukeyHSD(aov_group)

#provides main effects at different levels
library(emmeans)
group_mod <- ineq_group_data %>%
  group_by(merit) %>%
  emmeans_test(security_spending ~ inequality, p.adjust.method = "bonferroni")
```

```{r group-mediat-predict, eval=FALSE, echo=TRUE}
#predicting mediator
m_group_med1 <- lm(likely_attack ~ outgroup*agentic, data = ineq_group_data)
```


```{r group-likely-security, eval=FALSE, echo=TRUE}
# test for relationship between p. attack likelihood and security spending
m_group_likely_security <- lm(security_spending ~ likely_attack, data = ineq_group_data)
```



```{r group-mediat-dv, eval=FALSE, echo=TRUE}
# model with mediator: likely_attack (or perceived likelihood of partner attacking)
m_group_med2 <- lm(security_spending ~ agentic*outgroup + likely_attack, 
                 data = ineq_group_data)
```



```{r group-mod-med, eval=FALSE, echo = TRUE}
# see https://ademos.people.uic.edu/Chapter15.html#41_create_the_necessary_regression_models
m_group_modmed_outgroup <- mediate(m_group_med1, m_group_med2,    
                           covariates = list(outgroup = 1), boot = TRUE,   
                           boot.ci.type = "bca", sims = 2000, treat="inequality",
                           mediator="likely_attack")
plot(m_group_modmed_outgroup, xlim = 0:1)
summary(m_group_modmed_outgroup) 
# Specify mediation at low visibility
m_group_modmed_ingroup <- mediate(m_group_med1, m_group_med2,    
                           covariates = list(outgroup = 0), boot = TRUE,   
                           boot.ci.type = "bca", sims = 2000, treat="inequality",
                           mediator="likely_attack")
plot(m_group_modmed_ingroup, xlim = 0:1)
summary(m_group_modmed_ingroup) 
```



```{r group-modmed-test, eval=FALSE, echo = TRUE}
modmed_testgroup <- mediate(m_group_modmed_outgroup, m_group_modmed_ingroup, 
                            boot = TRUE,  boot.ci.type = "bca", sims = 2000, 
                            treat="inequality", mediator="likely_attack")   
#We don't specify anything about the moderator in this code yet
group_modmed_test <- test.modmed(modmed_testgroup, covariates.1 = list(outgroup = 0),   
            covariates.2 = list(outgroup = 1), sims = 2000)
#Here we specify both levels of the moderator that we want to test
group_modmed_test
```




## Assumptions and hypothesis testing

Below is the code for testing ANOVA assumptions

```{r anova-check, eval=FALSE, echo=T}
# Normality plots
ggqqplot(residuals(m_vis))
# Normality by condition
ggqqplot(ineq_vis_data, "security_spending", ggtheme = theme_bw()) +
  facet_grid(inequality ~ visibility)
# Normality test - significant with large samples
shapiro_test(residuals(m_vis))
# levene test for homogeneity of variance
ineq_vis_data %>% levene_test(security_spending ~ inequality*visibility)
```

The code for testing ANOVA hypotheses

```{r statistical-test, eval=FALSE, echo=T}
res.aov <- ineq_vis_data %>% rstatix::anova_test(security_spending ~ inequality*visibility)
# test main effects at different levels
ineq_vis_data %>%
  group_by(visibility) %>%
  rstatix::anova_test(security_spending ~ inequality, error = m_vis)
ineq_vis_data %>% 
  emmeans_test(
    security_spending ~ inequality, p.adjust.method = "bonferroni",
    model = m_vis
    )
```

