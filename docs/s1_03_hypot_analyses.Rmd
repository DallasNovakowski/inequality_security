---
title: "s1_03_hypot_analyses"
author: "Dallas Novakowski"
date: "20/01/2022"
output: html_document
---

```{r hypot-setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE, eval = FALSE, message = F, warning = F)
library(tidyverse)
library(kableExtra)
library(lme4)
library(rstatix)  # t_test; identify_outliers
# library(stats)  #aov function
library(ggpubr)  #ggqqplot
  library(afex) #aov_ez
# library(TOSTER)
library(mediation)
mediate <- mediation::mediate

library(emmeans)

source(here::here("scripts","hypotheses.R"), local = knitr::knit_global())
source(here::here("scripts","measures.R"), local = knitr::knit_global())

```

```{r testdata,echo=FALSE}
#used for 
set.seed(1234) #Standardizes the numbers generated by rnorm; see Chapter 5
N <- 200 #Number of participants; graduate students
inequality <- sample(c(0,1), replace=TRUE, size=N)
pnum <- seq_len(N)

stake_strings <- c("histak_loprob_loprice", "histak_loprob_hiprice", "histak_hiprob",
"lostak_loprob_loprice", "lostak_loprob_hiprice", "lostak_hiprob") 

# stake <- as.factor(sample(stake_strings, replace=TRUE, size=N))

envy_lik <- round(1+1.5*inequality + rnorm(N, 0,2),2) #Suspected mediator

security_spent <- 2*envy_lik + rnorm(N, 0, 5) #DV

envy_lostak <- 1.5*inequality + rnorm(N, 0, 5)
envy_histak <- 1.5*inequality + rnorm(N, 0, 5)
ss_lostak <- 2*envy_lostak + rnorm(N, 0, 5)
ss_histak <- 2*envy_histak + rnorm(N, 0, 5)

inequality <- as.factor(inequality)

stake_diff <- ss_histak - ss_lostak

ineq_data <- data.frame(pnum,inequality,envy_lostak,envy_histak,ss_lostak,ss_histak,stake_diff,security_spent,envy_lik)
```

## Study 1a/1b, Analysis Plan {.unlisted .unnumbered}

```{r envy-measure, eval = F}
lostak_envy_items <- c("partner_envy_lostak", "partner_jealous_lostak", 
        "partner_frustrated_lostak", "partner_bitter_lostak")

histak_envy_items <- c("partner_envy_histak", "partner_jealous_histak",
                       "partner_frustrated_histak", "partner_bitter_histak")


# Acceptable if mean alpha >= .7
# Otherwise, drop each item until >= .7 is achieved, >= 3 items acceptable
# If no >= .7 solution found, forego mediation analyses

ltm::cronbach.alpha(ineq_data$ineq_data
    [,lostak_envy_items],CI=TRUE)

ltm::cronbach.alpha(ineq_data[,histak_envy],CI=TRUE)

# Summing of envy items for each within-subjects condition
ineq_data$envy_lostak <- rowSums(ineq_data
    [,lostak_envy_items])

ineq_data$envy_histak <- rowSums(ineq_data
    [,histak_envy_items])
```

```{r 1a-2b2w-long, echo = FALSE}
ineq_data_long <- ineq_data %>% 
  gather(cell, value, ends_with("stak")) %>%
  mutate(stake_cond = str_sub(cell,1,end=-8),
         cell = str_sub(cell,-6,-1)) %>%
  # select(pnum, inequality, stake_cond, cell, value) %>%
  spread(key = stake_cond, value = value)

ineq_data_long <- rename(ineq_data_long, stake_cond=cell,
                         security_spending = ss,
                         likely_envy = envy)
```

```{r long-summary-security}
# see summary stats
ineq_data_long %>%
  group_by(stake_cond, inequality) %>%
  get_summary_stats(security_spending, type = "mean_sd")

# outlier test
ineq_data_long %>%
  group_by(stake_cond, inequality) %>%
  identify_outliers(security_spending)

# If outliers present, winzorize

# Shapiro normality test
ineq_data_long %>%
  group_by(stake_cond, inequality) %>%
  shapiro_test(security_spending)

#qqplots normailty plots
ggqqplot(ineq_data_long, "security_spending", ggtheme = theme_bw()) +
  facet_grid(inequality ~ stake_cond)

#homogeneity of variance
ineq_data_long %>%
  group_by(stake_cond) %>%
  levene_test(security_spending ~ inequality)

# homogeneity of covariances - only signals problems 
#when p < 0.001 and your sample sizes are unequal
# Fix:  separating your analyses into distinct 
#repeated measures ANOVAs for each group. 
#Alternatively, you could omit the 
#interpretation of the interaction term.
# At minimum. Report violation
box_m(ineq_data_long[, "security_spending", drop = FALSE], 
      ineq_data_long$inequality)
```

```{r long-summary-envy, echo = F}
ineq_data_long %>%
  group_by(stake_cond, inequality) %>%
  get_summary_stats(likely_envy, type = "mean_sd")

# outlier test
ineq_data_long %>%
  group_by(stake_cond, inequality) %>%
  identify_outliers(likely_envy)

#shapiro normality test
ineq_data_long %>%
  group_by(stake_cond, inequality) %>%
  shapiro_test(likely_envy)

#qqplots normailty plots
ggqqplot(ineq_data_long, "likely_envy", ggtheme = theme_bw()) +
  facet_grid(inequality ~ stake_cond)

#homogeneity of variance
ineq_data_long %>%
  group_by(stake_cond) %>%
  levene_test(likely_envy ~ inequality)

# homogeneity of covariances - only signals problems 
box_m(ineq_data_long[, "likely_envy", drop = FALSE], 
      ineq_data_long$inequality)
```

### Hypothesis 1  {.unlisted .unnumbered}

**H1):** `r hypotheses[1]`, or in terms of the model: **H1):** `r h1.1`

```{r study1a-anova}
# Automatically applies Greenhouse-Geisser when violating sphericity.

afex_options(es_aov         = 'pes',
             correction_aov = 'GG',
             emmeans_model  = 'univariate'
             # ,include_aov = TRUE
             )

ineq_anova_mixed <-  aov_ez(id='pnum',
                            dv='security_spending',
                            data=ineq_data_long,
                            within = c('stake_cond'),
                            between = c('inequality')
                            )
#Cohen's f chosen because of it's correspondence to power analysis
ineq_anova_mixed_cohens_f <- effectsize::cohens_f(ineq_anova_mixed, 
    alternative="two.sided",verbose = FALSE,generalized = FALSE)

afex_plot(ineq_anova_mixed,  ~ inequality,  ~ stake_cond, error = "within")
```

```{r study1a-pc}
ineq_mixed_emm <- emmeans(ineq_anova_mixed, 
                          specs = pairwise ~ stake_cond*inequality)

ineq_mixed_emm$contrasts %>%
    summary(infer = TRUE)%>%
    as.data.frame()
```

```{r lmer-ineq-mixed-anova, echo=F}
# ineq_lmer <- lmerTest::lmer(security_spending ~ inequality*stake_cond 
#                             + (1 | pnum), data = ineq_data_long, REML=TRUE)
# 
# ineq_lmer_anova <- round(anova(ineq_lmer, ddf = "Kenward-Roger"),3)
# 
# ineq_lmer_cohensf <- effectsize::cohens_f(ineq_lmer_anova, 
#     alternative="two.sided",verbose = FALSE)
```

```{r grouping-lostak, echo =F}
#this use of N looks right- for each between-subjects factor
grouped_lostak <- ineq_data %>%
  group_by(inequality) %>%
  summarise_at(vars(ss_lostak), list(mean = mean,sd=sd,n=length))

grouped_lostak$se <- grouped_lostak$sd/sqrt(grouped_lostak$n)

lostak_dif <- as.numeric(unname(grouped_lostak[2,2] - 
                                  grouped_lostak[1,2]))

lostak_se <- as.numeric(unname(sqrt(grouped_lostak[2,5] +
                                      grouped_lostak[1,5])))

lostak_diff_sd <- as.numeric(sqrt(grouped_lostak[2,5]^2 +
                                    grouped_lostak[1,5]^2))
```

```{r grouping-histak, echo = F}
#this use of N looks right- for each between-subjects factor
grouped_histak <- ineq_data %>%
  group_by(inequality) %>%
  summarise_at(vars(ss_histak), list(mean = mean,sd=sd,n=length))

grouped_histak$se <- grouped_histak$sd/sqrt(grouped_histak$n)

histak_dif <- as.numeric(unname(grouped_histak[2,2] - 
                                  grouped_histak[1,2]))

histak_se <- as.numeric(unname(sqrt(grouped_histak[2,5] +
                                      grouped_histak[1,5])))

histak_diff_sd <- as.numeric(sqrt(grouped_histak[2,5]^2 +
                                    grouped_histak[1,5]^2))
```

```{r overall-equiv-computation, echo = F}
#this use of N may be wrong - uses the overall 
#sample size instead of some specification from between groups 
diff_diff <- histak_dif - lostak_dif

diff_se <- sqrt(lostak_se+ histak_se)

pooled <- sqrt(((N-1)*histak_diff_sd^2 + 
                  (N-1)*lostak_diff_sd^2) / (N+N-2))

diff_sd <- diff_se*sqrt(N)
```


```{r t-tost, echo = F}
#An equivalence test COULD be used to determine whether the effect of inequality significantly smaller than a minimally large effect size.

ineq_mixed_tost <- tsum_TOST(
m1 = histak_dif,
sd1 = histak_diff_sd,
n1 = N,
m2 = lostak_dif,
sd2 = lostak_diff_sd,
n2 = N,
r12 = .5,
hypothesis = "EQU",
paired = TRUE,
var.equal = FALSE,
low_eqbound = -pooled*.2,
high_eqbound = pooled*.2,
mu = 0,
eqbound_type = "raw",
alpha = 0.05,
bias_correction = TRUE,
rm_correction = FALSE
)
```

### Hypothesis 2  {.unlisted .unnumbered}

**H2)**: `r h1a`, or in terms of the model, **H2)**: `r h1am`.

**H2.1)**, mediation step 1: `r h1a.1`

**H2.2)**, mediation step 2: `r h1a.2`

**H2.3)**, mediation step 3: `r h1a.3`.

```{r study 1a-med-mixed}
m_mixed_med1 <- lmer(likely_envy ~ inequality  + (1| pnum) + 
                       stake_cond, data = ineq_data_long)
#returns as singular - likely artifact of data generation process
m_mixed_med2 <- lmer(security_spending ~ likely_envy + inequality  + 
                       (1| pnum) + stake_cond, data = ineq_data_long)

m_mixed_total <- lmer(security_spending ~ inequality  + (1| pnum) + 
                        stake_cond, data = ineq_data_long)

m_mixed_med_full <- mediate(m_mixed_med1, m_mixed_med2, 
    #                         boot = TRUE,   
    # boot.ci.type = "bca", 
    sims = 2000,
    treat="inequality",
                           mediator="likely_envy")

plot(m_mixed_med_full)
summary(m_mixed_med_full)
```

## Study 1c, Analysis Plan {.unlisted .unnumbered}

```{r merit-items, eval=FALSE, echo = F}
ineq_data$envy_lik <- rowSums(ineq_data[,c("partner_envy", 
  "partner_jealous", "partner_frustrated", "partner_bitter")

ltm::cronbach.alpha(ineq_data$likely_envy,CI=TRUE)
# Acceptable if mean alpha >= .7
# Otherwise, try dropping each item until >= .7 is achieved
# If no >= .7 solution found, forego mediaiton analyses

reasonable_income_text <- "My partner's assigned income is reasonable"
fair_distribution_text <- "The way incomes were given for this game is fair"
deserved_income_text <- "I deserve my income for this game"
deserved_role_text <- "I deserve my role for this game"

game_fair_text <- "The way incomes were given for this game is fair"
self_fair_text <-"My assigned income is fair"
other_fair_text <-"My partner's assigned income is fair"
```


```{r test-merit-data, echo = F}
# Used for making test data
ineq_merit_data <- ineq_data

ineq_merit_data$merit <- sample(c(0,1), replace=TRUE, size=N)

ineq_merit_data$merit <- ifelse(ineq_merit_data$merit == 1,
                                "merit", "random")

ineq_merit_data$inequality <- ifelse(ineq_merit_data$inequality == 1,
                                     "unequal", "equal")

ineq_merit_data$inequality <- as.factor(ineq_merit_data$inequality)
ineq_merit_data$merit <- as.factor(ineq_merit_data$merit)
```



```{r merit-assumptions, echo = FALSE}
outliers_merit <- ineq_merit_data %>%
  group_by(merit, inequality) %>%
  identify_outliers(security_spent)

# Build the linear model
lm_merit  <- lm(security_spent ~ as.factor(inequality)*as.factor(merit),
             data = ineq_merit_data)

# Create a QQ plot of residuals
qq_merit <- ggqqplot(residuals(lm_merit))

#shapiro normality
shap_merit <- shapiro_test(residuals(lm_merit))

#normality by groups
shap_g_merit <- ineq_merit_data %>%
  group_by(merit, inequality) %>%
  shapiro_test(security_spent)

# qqplot by group
qq_g_merit <- ggqqplot(ineq_merit_data,
                           "security_spent", ggtheme = theme_bw()) +
  facet_grid(inequality ~ merit)

# Due to large samples, no alternative method 
#will be used in the case of nonnormality

levene_merit <- ineq_merit_data %>% levene_test(security_spent ~ 
    as.factor(inequality)*as.factor(merit))

# Due to large samples, no alternative method will 
#be used in the case of heterogeneity of variance


# https://easystats.github.io/effectsize/articles/effectsize.html
# see above for 95%ci for eta squared
```

### Hypothesis 3 {.unlisted .unnumbered}

**H3)**: `r h2`. Or more precisely, **H3)**: `r h2.1`

```{r merit-anova-afex}
anova_merit <-  aov_ez(id='pnum',
                            dv='security_spent',
                            data=ineq_merit_data,
                            between = c('inequality',"merit"))

anova_merit_cohensf <- effectsize::cohens_f(anova_merit, 
 alternative="two.sided",verbose = FALSE,generalized = FALSE)

afex_plot(anova_merit,  ~ inequality,  ~ merit)
```

**H3.1)**: `r h2.2`

```{r merit-anova-pc}
merit_emm <- emmeans(anova_merit, specs = pairwise ~ inequality*merit)

merit_pc <- merit_emm$contrasts %>%
    summary(infer = TRUE)%>%
    as.data.frame()

merit_pc
```

## Study 1d, Analysis Plan {.unlisted .unnumbered}

```{r group-make-data, echo = F}
ineq_group_data <- ineq_merit_data

ineq_group_data$agentic <- 
  as.factor(
  sample(c(0,1), replace=TRUE, size=N)
  )

ineq_group_data$agentic <- as.factor(ifelse(ineq_group_data$agentic == 1,
                                "agent", "random"))

ineq_group_data$outgroup <- as.factor(sample(c(0,1), replace=TRUE, size=N))

ineq_group_data$outgroup <- as.factor(ifelse(ineq_group_data$outgroup == 1,
                                "outgroup", "ingroup"))
```

```{r group-assumptions, echo = F}
outliers_group <- ineq_group_data %>%
  group_by(outgroup, agentic) %>%
  identify_outliers(security_spent)

# If outliers present, winzorize

# Build the linear model
lm_group  <- lm(security_spent ~ 
                  as.factor(agentic)*as.factor(outgroup),
             data = ineq_group_data)

# Create a QQ plot of residuals
qq_grouped_group <- ggqqplot(residuals(lm_group))

#shapiro normality
shap_group <- shapiro_test(residuals(lm_group))

#normality by groups
shap_g_group <- ineq_group_data %>%
  group_by(outgroup, agentic) %>%
  shapiro_test(security_spent)

# qqplot by group
qq_g_group <- ggqqplot(ineq_group_data,
                           "security_spent", ggtheme = theme_bw()) +
  facet_grid(agentic ~ outgroup)

# Due to large samples, no alternative method will 
#be used in the case of nonnormality

levene_group <- ineq_group_data %>% levene_test(security_spent ~ 
    as.factor(agentic)*as.factor(outgroup))

# Due to large samples, no alternative method will be 
#used in the case of heterogeneity of variance
```

### Hypothesis 4 {.unlisted .unnumbered}

**H4):** `r h3`. Or more precisely, **H4):** `r h3.1`

```{r group-anova-afex}
anova_group <-  aov_ez(id='pnum',
                            dv='security_spent',
                            data=ineq_group_data,
                            between = c('agentic',"outgroup"))

anova_group_cohensf <- effectsize::cohens_f(anova_group, 
    alternative="two.sided",verbose = FALSE,generalized = FALSE)

afex_plot(anova_group,  ~ agentic,  ~ outgroup)
```

**H4.1):** `r h3.2`

```{r group-anova-pc}
group_emm <- emmeans(anova_group, specs = pairwise ~ agentic*outgroup)

group_pc <- group_emm$contrasts %>%
    summary(infer = TRUE)%>%
    as.data.frame()
```
